<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>OddWebsite</title><description>Hi, I'm Michael, a ðŸ’» programmer, ðŸŽ¸ music lover, and ï£¿ enthusiast.</description><link>https://oddmagnet.github.io</link><language>en</language><lastBuildDate>Mon, 3 Aug 2020 18:13:26 +0200</lastBuildDate><pubDate>Mon, 3 Aug 2020 18:13:26 +0200</pubDate><ttl>250</ttl><atom:link href="https://oddmagnet.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://oddmagnet.github.io/blog/Splash%20Test</guid><title>Splash Test</title><description>A test of the splash plugin for publish.</description><link>https://oddmagnet.github.io/blog/Splash%20Test</link><pubDate>Fri, 31 Jul 2020 17:10:00 +0200</pubDate><content:encoded><![CDATA[<h1>Splash Test</h1><p>Just some Swift code to test out the Splash plugin, which should highlight the below code.</p><pre><code><span class="keyword">struct</span> Address {
	<span class="keyword">let</span> street: <span class="type">String</span>
	<span class="keyword">let</span> city: <span class="type">String</span>
	<span class="keyword">let</span> zip: <span class="type">Int</span>
}

<span class="keyword">struct</span> Student: <span class="type">Person</span> {
	<span class="keyword">let</span> id = <span class="type">UUID</span>()
	<span class="keyword">let</span> name: <span class="type">String</span>
	<span class="keyword">let</span> age: <span class="type">Int</span>
	<span class="keyword">let</span> address: <span class="type">Address</span>
}

<span class="keyword">let</span> address = <span class="type">Address</span>(street: <span class="string">"1 Apple Park Way"</span>, city: <span class="string">"Cupertino"</span>, zip: <span class="number">95014</span>)

<span class="keyword">let</span> student = <span class="type">Student</span>(name: <span class="string">"Tim Cook"</span>, age: <span class="number">59</span>, address: address)
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://oddmagnet.github.io/blog/Debugging</guid><title>Debugging Techniques</title><description>Some notes on debugging techniques.</description><link>https://oddmagnet.github.io/blog/Debugging</link><pubDate>Fri, 31 Jul 2020 13:52:00 +0200</pubDate><content:encoded><![CDATA[<h1>Debugging Techniques</h1><p>A collection of some techniques that I learned over time, so far.</p><h2>Print Statements</h2><p>I don't think there's much to write about these. Everybody has used them at some point and whoever says they never did is lying. It's not the worst possible way of debugging, certainly better than just staring at the code, but there are more efficient ways.</p><h2>Watching Variables</h2><p>When a variable crashes the app and you don't know why, it's often a good idea to watch it while debugging. Luckily this doesn't need to be done manually, after setting a breakpoint and running the code Xcode will show an overview of variables in the debug area, simply right-clicking a variable and selecting <code>Watch VariableName</code> is enough.</p><p>In the <em>Breakpoint Navigator</em> (<code>âŒ˜8</code>) you'll then not only see the breakpoints you set, but also the <em>Watchpoints</em>, the variables Xcode is watching. When continuing with the apps execution Xcode will not only stop at breakpoints, but every time the watched variable changes and show exactly what changed.</p><p>Once Xcode stop at a point where the variable changed to an unexpected value - and likely shows the rather unhelpful assembly code -, the <em>Debug Navigator</em> (<code>âŒ˜7</code>) can be used to navigate through the function calls and find the bug.</p><p>Compared to print statements it's much easier to watch a variable once and just check the function where it's value got changed unexpectedly instead of placing prints everywhere.</p><h2>Exception Breakpoints</h2><p>Sometimes code crashes and we're left nowhere close to the code we actually wrote and we need scroll up in the debug output, past all the stuff that doesn't tell us anything, to get to the point where the error actually happened.</p><p>In the <em>Breakpoint Navigator</em>, using the '+' symbol in the bottom left, an <em>Exception Breakpoint</em> can be created, this sort of breakpoint will stop the execution of the code as soon as an exception is thrown, which means the execution doesn't go through to the crash.</p><p>The debug area might still now show helpful output, going back into the <em>Debug Navigator</em> and selecting the last function call, then entering <code>po $arg1</code> in the console window will print the objective-c description of an object, in this case the error message that was previously shown at the top of a very, very long output in the console.</p><p>Since this is such a common scenario, it's possible to edit the breakpoint and add an action, that does exactly that, execute the command from above in the console when the breakpoint is hit. Even more, it's possible to right-click it and choose <em>Move to</em> followed by selecting <em>User</em>, which will make the breakpoint available in all projects, not just the current one.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://oddmagnet.github.io/blog/100Days</guid><title>100 Days of Swift UI</title><description>An overview of my experience with the 100 Days of SwiftUI challenge.</description><link>https://oddmagnet.github.io/blog/100Days</link><pubDate>Thu, 30 Jul 2020 14:26:00 +0200</pubDate><content:encoded><![CDATA[<h1>100 Days of Swift UI</h1><h2>Introduction</h2><p>This section was mostly centered on learning the basics of the Swift programming language, for the most part my experience with other programming languages translated over to Swift. Notable exceptions were Optionals and the way Protocols and Extensions are used in Swift</p><h2>Starting SwiftUI</h2><p>While I learned a bit of iOS programming as a hobby, that was mostly centered on UIKit, so the section was the first time I really learned more about SwiftUI, the main focus was on learning basic view types like <strong>Stacks</strong>, <strong>NavigationView</strong>, <strong>Forms</strong> and how to make use of the concept that views are a function of their state.</p><p>Other important aspects were how to use <strong>buttons</strong>, showing <strong>alerts</strong>. In the technique project I learned more about how views and viewmodifiers work under the hood, why structs are used for most things and why 'some View' is used so much</p><h2>Expanding your skills</h2><p>After the first section I was able to easily create basic UI's and now this section focused on expanding my knowledge of all the views SwiftUI offers, in this section I learned about <strong>Stepper</strong>, <strong>DatePicker</strong> and <strong>List</strong> views, got to know a bit of machine learning with <strong>Create ML</strong> and learned how to work with dates in Swift.</p><p>Additionally I got more practice with <strong>@State</strong>, <strong>Alert</strong> and <strong>NavigationView</strong> and also learned how to load resources from the bundle, in the technique project I learned about animations and how easy it can be to animate changes in state</p><h2>Scaling up to bigger apps</h2><p>After the last two sections I was able to create simple apps that can do simple things in a short time, now this chapter focused on the things that are needed to create bigger apps, amongst other things a new form of sharing state with <strong>@ObservedObject</strong>, how to show/hide views, delete items from lists, storing user settings and archiving objects.</p><p>I also got more in-depth knowledge of why <strong>@State</strong> only works with structs, how to work with hierachical Codable data and how to push views on the navigation stack and learned about <strong>GeometryReader</strong>, <strong>ScrollView</strong> and how to create custom <strong>Paths</strong> and <strong>Shapes</strong> in SwiftUI.</p><h2>Focus on data</h2><p>The focus of this section, like the title says, was on data, sending and receiving it, and using <strong>Core Data</strong> with SwiftUI, here I learned how to add <strong>Codable</strong> conformance to <strong>@Published</strong> properties, using <strong>URLSession</strong> to receive and send data, about <strong>@FetchRequest</strong>, how to sort and filter those requests and how to delete data, how to create custom <strong>NSManagedObject</strong> subclasses, using constraints and relationships.</p><p>Additionally I practiced using more custom components, size classes and type erasure</p><h2>Views and View controllers</h2><p>After getting a grasp on how to handle data, the focus went back to views and their controllers, in this section I learned about custom bindings, <strong>ActionSheet</strong>, wrapping <strong>UIViewController</strong> in SwiftUI views and using <strong>coordinators</strong> to manage them, how to save and import images from the photo library and filter them with <strong>Core Image</strong>, adding <strong>Comparable</strong> to custom types, writing to the documents directory, switching view states with enums, using <strong>MapKit</strong>, Touch/Face ID and extending existing types to support <strong>ObservableObject</strong>.</p><p>In the technique project I learned about accessibility, how to identify views, hide and group accessibility data and reading the value of controls</p><h2>Controlling UI Flow</h2><p>The more views there are, the more need for a good UI flow there is, this section taught me how to create and use <strong>TabViews</strong>, using <strong>@EnvironmentObject</strong>, adding <strong>context menus</strong>, scheduling notifications and adding package dependencies, understanding how the <strong>Result</strong> type works, how to manually push <strong>ObservableObject</strong> changes, dynamically filtering a list, using <strong>gestures</strong> and haptic feedback with <strong>Core Haptics</strong>.</p><p>Furthermore I learned about disabling user interactiviy, <strong>Timers</strong>, getting notified when the app changes to back-/foreground and how to support specific accessibility needs.</p><p>For the technique project I learned how layout works in SwiftUI, how to use and create alignment guides and how GeometryReader works and can be used to easily create nice effects.</p><h2>One last project</h2><p>For the last project the focus was on creating an app the specifically works well on iPads, for this I learned using <strong>NavigationView</strong> with two views, using <strong>Alerts</strong> and <strong>Sheets</strong> with optionals and using <strong>Groups</strong> as transparent layout containers.</p><p>One thing that stood out to me was the last wrap up challenge of adding sorting and filtering to the list which sounded intimidating at first, but was surprisingly easy to code in a <strong>swifty</strong> way.</p><h1>Day 100: Final Exam</h1><p><a href="https://oddmagnet.github.io/certificate.jpg">Certificate</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://oddmagnet.github.io/blog/first-post</guid><title>My first post</title><description>A description of my first post.</description><link>https://oddmagnet.github.io/blog/first-post</link><pubDate>Thu, 30 Jul 2020 13:54:00 +0200</pubDate><content:encoded><![CDATA[<h1>My first post</h1><p>My first post's text.</p>]]></content:encoded></item></channel></rss>